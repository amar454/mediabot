
import discord
from discord import member
from discord.ext import commands
import json
from discord.ext.commands.core import command
import time
from datetime import datetime
import random
import os
from gtts import gTTS
import platform
import asyncio
import subprocess
import sys
import random 
from sympy import false
from pytube.exceptions import AgeRestrictedError
from discord.utils import get
from discord import FFmpegPCMAudio
from pytube import YouTube
msys = platform.uname()
if not os.path.isfile('bot_data.json'):
    with open('bot_data.json', "w") as f:
        f.seek(0)
        f.truncate()
        f.write(json.dumps({'admin_role_name':"Admin", "prefix":"!"}))
        f.close()
if not os.path.isdir('mp3s'):
    os.mkdir('mp3s')
def open_bot_data():
    with open('bot_data.json', 'r+') as b: # return bot data file, prefix stuff etc
        b.seek(0)
        data = json.load(b)
        b.close()
    return data
def open_member_data():
    with open('member_data.json', 'r+') as f: # return member autogenerated data file
        f.seek(0)
        data = json.load(f)
        f.close()
    return data
def write_bot_data(to_write): # writes to bot data file
    with open('bot_data.json', 'r+') as bw:
        bw.seek(0)
        bw.truncate()
        bw.write(to_write)
        bw.close()
def write_member_data(to_write): # writes to bot data file
    with open('member_data.json', 'r+') as fw:
        fw.seek(0)
        fw.truncate()
        fw.write(to_write)
        fw.close()   
def check_role(to_check,role_name=open_bot_data()["admin_role_name"]): # checks if given role is in author.roles, by default checks for admin 
    if role_name not in '{0.author.roles}'.format(to_check.message):
        return False
    else:
        return True             

def log_command(name: str, author: str, code: int): # takes some command info and the time and puts it in the console for debugging
    with open('log.txt', 'a') as f:
        f.write(f'command {name} used by {author} at {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}. {code}\n')
        f.close()
    return print(f'command {name} used by {author} at {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}. {code}')
intents = discord.Intents.all() # some absolute discord bullshitery
intents.members = True # some absolute discord bullshitery pt 2. basically sets some member permission thing to access guild.member routines idfk i just looked at the documentation 


client = commands.Bot(command_prefix= open_bot_data()["prefix"], intents=intents)

@client.event
async def on_ready():
    print('Bot has been initialized.')
    await client.change_presence(activity=discord.Game(name=open_bot_data()["prefix"]))
@client.event
async def on_member_join(ctx):
    print(f"{ctx} has joined the server ")
@client.event
async def on_member_leave(ctx):
    print(f"{ctx} has left the server :(")    
@client.command()
async def ping(ctx): # first command. 
    await ctx.send('Pong!')
    log_command('pong', ctx.author, 0)
@client.command()
async def changeprefix(ctx, prefix):
    '''Allows the user to change the command_prefix if they are an admin'''
    if not check_role(ctx):
        await ctx.send('err: You do not possess the appropriate roles for this command')
        return 
    data = open_bot_data()
    data["prefix"] = prefix
    print(data)
    write_bot_data(json.dumps(data))
    log_command('changeprefix', ctx.author, 0)
    await ctx.send(f"Prefix changed to {prefix}")
    subprocess.call([sys.executable, os.path.realpath(__file__)] + sys.argv[1:]) # restarts the program to make the changes into effect
@client.command()
async def restart(ctx):
    '''Restarts the actual program using a subprocess method, useful for testing'''
    if not check_role(ctx):
        await ctx.send('err: You do not have the proper roles to use this command')
        log_command('restart', ctx.author, -1)
        return 
    await ctx.send(f"Restarting...")
    log_command('restart', ctx.author, 0)
    subprocess.call([sys.executable, os.path.realpath(__file__)] + sys.argv[1:]) 
@client.command(pass_context=True)
async def play(ctx, filename):
    '''Plays locally saved files'''
    channel = ctx.message.author.voice.channel
    if not channel:
        await ctx.send("err: You are not connected to a voice channel")
        return
    voice = get(client.voice_clients, guild=ctx.guild)
    if voice and voice.is_connected():
        await voice.move_to(channel)
    else:
        voice = await channel.connect()
    source = FFmpegPCMAudio(f"mp3s/{filename}")
    player = voice.play(source) 
    log_command('restart', ctx.author, 0)   
@client.command()
async def playyt(ctx, link, name):
    '''Downloads the audio from youtube link then saves it into a new song in the local saved'''
    voice = get(client.voice_clients, guild=ctx.guild)
    try:
        pt = YouTube(link)
        video = pt.streams.filter(only_audio=True).first()
        out_file = video.download(filename=f'mp3s/{name}')
    except AgeRestrictedError:
        await ctx.send('err: Age restricted video')
        return 
    channel = ctx.message.author.voice.channel
    if not channel:
        await ctx.send("err: You are not connected to a voice channel")
        return
    voice = get(client.voice_clients, guild=ctx.guild)
    if voice and voice.is_connected():
        await voice.move_to(channel)
    else:
        voice = await channel.connect()
    source = FFmpegPCMAudio(f"mp3s/{name}")
    player = voice.play(source) 
    return 
@client.command()
async def pause(ctx):
    '''Pause player'''
    vc = get(client.voice_clients, guild=ctx.guild)
    vc.pause()
    return 
@client.command()
async def resume(ctx):
    '''Resume player'''
    vc = get(client.voice_clients, guild=ctx.guild)
    vc.resume()
    return 
@client.command()
async def listsongs(ctx):
    '''List locally saved songs'''
    data = ''
    for f in os.listdir('mp3s/'):
        data += f'{f}\n'
    await ctx.send(data)
    return 
@client.command()
async def killplayer(ctx):
    '''Kill player'''
    voice = get(client.voice_clients, guild=ctx.guild)
    voice.cleanup()
    voice.disconnect()
    return 
@client.command()
async def delete(ctx, filename):
    if "Owner" not in '{0.author.roles}'.format(ctx.message):
        await ctx.send("err:")
    else:
        try:
            os.remove(f'mp3s/{filename}')
            await ctx.send(f'mp3s/{filename} has been nuked')
        except FileNotFoundError:
            await ctx.send('err: That file does not exist')


client.run('key')